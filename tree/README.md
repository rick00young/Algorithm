## 二叉树的性质
#### 性质一
>在二叉树的第i层上至多有2^(i-1)个结点(i>=1);

#### 性质二
> 深度为k的二叉树至多有2^k-1个结点(k>=1);

#### 性质三
>对任何一棵二叉树T,如果其终端结点数为n0,度为2的结点数为n2,则n0=n2+1;

> n1表示度为1的结点数, n2表示度为2的结点数,n0表示终端结点数也就是叶子结点数;总分支线=n-1=n1+2n2;同时n=n0+n1+n2;所以n1+2n2+1=n0+n1+n2,推出n0=n2+1

#### 性质四
> 具有n个结点的完全二叉树的深度为|log2(n)|+1 (|x|表示不大于x的最大整数)

> 根据性质二:n=2^k - 1;可反推出树的深度为k=log2(n+1);
> 根据完全二叉树与满二叉树的关系可得到:

	同样深度的完全二叉树与满二叉树,
	完全二叉树的结点数少于等于2^k-1,
	但一定多于2^(k-1)-1: 
		2^(k-1)-1 < n <= 2^k-1
		=> 2^(k-1) <= n < 2^k
		两边取对数
		=> k-1<=log2(n)<k
		=> k=|log2(n)|+1
		
#### 性质五
> 如果对一棵有n个结点的完全二叉树,(其深度为|log2(n)|+1)的结点按层序编号(从第1层到第|log2(n)|+1层,每层从左到右),对任一结点i(1<=i<=n)有:

> 1. 如果i=1,则结点i是二叉树的根,无又亲;如果i>1,则其双亲是结点|i/2|;

> 2. 如果2i>n,则结点i无左孩子(结点i为叶子结点);否则其左孩子是结点2i;

> 3. 如果2i+1>n,则结点i无右孩子;否则其右孩子是结点2i+1;



顺序存储结构一般只用于完全二叉树

#### 线索二叉树
> 同时有指针指向其双亲

#### 赫夫曼树
> 1.根据给定的n个权值{w1, w2, w3,...,wn},构成n棵二叉树的集合F={T1,T2,...,Tn},其中每棵二叉树Ti中只有一个带权为wi的根结点,其左右子树为空

> 2.在F中选取两棵根结点的权值最小的树作为左右子树构造一棵新的二叉树,且置新的二叉树的根点的权值为其左右子树上根结点的权值之和.

> 3.在F中删除这两棵树,同时将新得到的二叉树加F中

> 4.重复2和3步骤,直到F只含有一棵树为止.

#### 赫夫曼树编码
>设需要编码的字符集为{d1, d2, d3, ..., dn},各个字符在电文中出次的次数或频率集合为{w1, w2, w3,...,wn},以d1,d2,d3,...,dn作为叶子结点,以w1,w2,w3,..,wn作为相应叶结点的权值来构造一棵赫夫曼,规定赫夫曼树的左分支代表0,右分支代表1,则从根结点到叶子结点所经过的路径分支组成的0和1的序列便成为该结点对应字符的编码,就是赫夫曼编码.

#### Trie树：
又名单词查找树，一种树形结构，常用来操作字符串。它是不同字符串的相同前缀只保存一份。
相对直接保存字符串肯定是节省空间的，但是它保存大量字符串时会很耗费内存（是内存）。
类似的有：

* 前缀树(prefix tree)，后缀树(suffix tree)，radix tree(patricia tree, compactprefix tree)，crit-bit tree（解决耗费内存问题），以及前面说的double array trie。
* 前缀树：字符串快速检索，字符串排序，最长公共前缀，自动匹配前缀显示后缀。
* 后缀树：查找字符串s1在s2中，字符串s1在s2中出现的次数，字符串s1,s2最长公共部分，最长回文串。 

trie 树的一个典型应用是前缀匹配，在我们输入时，搜索引擎会给予提示。

#### AVL树
一棵AVL树满足以下的条件:

* 1.它的左子树和右子树都是AVL树
* 2.左子树和右子树的高度差不能超过1

性质:

* 1.一棵n个结点的AVL树的其高度保持在0(log2(n)),不会超过3/2log2(n+1)
* 2.一棵n个结点的AVL树的平均搜索长度保持在0(log2(n)).
* 3.一棵n个结点的AVL树删除一个结点做平衡化旋转所需要的时间为0(log2(n)).

为了保证平衡，AVL树中的每个结点都有一个平衡因子（balance factor，以下用BF表示），它表示这个结点的左、右子树的高度差，也就是左子树的高度减去右子树的高度的结果值。AVL树上所有结点的BF值只能是-1、0、1。反之，只要二叉树上一个结点的BF的绝对值大于1，则该二叉树就不是平衡二叉树。下图演示了平衡二叉树和非平衡二叉树。

#### 红黑树
* 1.每个结点或者为黑色或者为红色。
* 2.根结点为黑色。
* 3.每个叶结点(实际上就是NULL指针)都是黑色的。
* 4.如果一个结点是红色的，那么它的两个子节点都是黑色的（也就是说，不能有两个相邻的红色结点）。
* 5.对于每个结点，从该结点到其所有子孙叶结点的路径中所包含的黑色结点数量必须相同。

一棵拥有n个内部结点的红黑树的树高h<=2log(n+1)

> 红黑树通过上面这种限制来保证它大致是平衡的——因为红黑树的高度不会无限增高，这样保证红黑树在最坏情况下都是高效的，不会出现普通排序二叉树的情况。 由于红黑树只是一个特殊的排序二叉树，因此对红黑树上的只读操作与普通排序二叉树上的只读操作完全相同，只是红黑树保持了大致平衡，因此检索性能比排序二叉树要好很多。 但在红黑树上进行插入操作和删除操作会导致树不再符合红黑树的特征，因此插入操作和删除操作都需要进行一定的维护，以保证插入节点、删除节点后的树依然是红黑树

红黑树应用比较广泛：

* 广泛用在C++的STL中。map和set都是用红黑树实现的。
* 著名的linux进程调度Completely Fair Scheduler,用红黑树管理进程控制块。
* epoll在内核中的实现，用红黑树管理事件块
* nginx中，用红黑树管理timer等
* Java的TreeMap实现

#### B\*树
是B+树的变体，在B+树的非根和非叶子结点再增加指向兄弟的指针；

B\*树定义了非叶子结点关键字个数至少为(2/3)\*M，即块的最低使用率为2/3（代替B+树的1/2）；

* B+树的分裂：当一个结点满时，分配一个新的结点，并将原结点中1/2的数据复制到新结点，最后在父结点中增加新结点的指针；B+树的分裂只影响原结点和父结点，而不会影响兄弟结点，所以它不需要指向兄弟的指针；
* B\*树的分裂：当一个结点满时，如果它的下一个兄弟结点未满，那么将一部分数据移到兄弟结点中，再在原结点插入关键字，最后修改父结点中兄弟结点的关键字（因为兄弟结点的关键字范围改变了）；如果兄弟也满了，则在原结点与兄弟结点之间增加新结点，并各复制1/3的数据到新结点，最后在父结点增加新结点的指针；
所以，B*树分配新结点的概率比B+树要低，空间使用率更高；
	
#### B树、B+树、LSM树	
[http://blog.csdn.net/u010853261/article/details/78217823](http://blog.csdn.net/u010853261/article/details/78217823)		

##### B树
B树是一种平衡多路搜索树，B树与红黑树最大的不同在于，B树的结点可以有多个子女，从几个到几千个。那为什么又说B树与红黑树很相似呢?因为与红黑树一样，一棵含n个结点的B树的高度也为O（lgn），但可能比一棵红黑树的高度小许多，应为它的分支因子比较大。所以，B树可以在O（logn）时间内，实现各种如插入（insert），删除（delete）等动态集合操作。

B树的定义如下：

* 根节点至少有两个子节点
* 每个节点有M-1个key，并且以升序排列
* 位于M-1和M key的子节点的值位于M-1 和M key对应的Value之间
* 其它节点至少有M/2个子节点
* 所有叶子结点位于同一层；		

B树的搜索：从根结点开始，对结点内的关键字（有序）序列进行二分查找，如果命中则结束，否则进入查询关键字所属范围的儿子结点；重复，直到所对应的儿子指针为空，或已经是叶子结点；

B树的特性：

* 关键字集合分布在整颗树中；
* 任何一个关键字出现且只出现在一个结点中；
* 搜索有可能在非叶子结点结束(树中所有结点都存储数据，与B+树这一点不同)；
* 其搜索性能等价于在关键字全集内做一次二分查找；
		
		
##### B+树
B+树是对B树的一种变形，与B树的差异在于：

* 有n棵子树的结点中含有n个关键字，每个关键字不保存数据，只用来索引，所有数据都保存在叶子节点。
* 所有的叶子结点中包含了全部关键字的信息，及指向含这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。
* 所有的非终端结点可以看成是索引部分，结点中仅含其子树（根结点）中的最大（或最小）关键字。
* 为所有叶子结点增加一个链指针，便于区间查找和遍历。
* 所有关键字都在叶子结点出现；
		
B+树的搜索：与B-树也基本相同，区别是B+树只有达到叶子结点才命中（B-树可以在非叶子结点命中），其性能也等价于在关键字全集做一次二分查找；

B+的特性：

* 非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储（关键字）数据的数据层；
* B+树的叶子结点都是相链的，因此对整棵树的遍历只需要一次线性遍历叶子结点即可。而且由于数据顺序排列并且相连，所以便于区间查找和搜索。而B树则需要进行每一层的递归遍历。相邻的元素可能在内存中不相邻，所以缓存命中性没有B+树好。

##### B树和B+树总结：
* B树：多路搜索树，每个结点存储M/2到M个关键字，非叶子结点存储指向关键字范围的子结点；所有关键字在整颗树中出现，且只出现一次，非叶子结点可以命中；

* B+树：在B-树基础上，为叶子结点增加链表指针，所有关键字都在叶子结点中出现，非叶子结点作为叶子结点的索引；B+树总是到叶子结点才命中；

* B+树虽然优点很多，但是B树也有优点，其优点在于，由于B树的每一个节点都包含key和value，因此经常访问的元素可能离根节点更近，因此访问也更迅速。

##### 为什么说B+tree比B树更适合实际应用中操作系统的文件索引和数据库索引？
* （1) B+tree的磁盘读写代价更低 
B+tree的内部结点并没有指向关键字具体信息的指针。因此其内部结点相对B树更小。如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说IO读写次数也就降低了。

举个例子，假设磁盘中的一个盘块容纳16bytes，而一个关键字2bytes，一个关键字具体信息指针2bytes。一棵9阶B-tree(一个结点最多8个关键字)的内部结点需要2个盘快。而B+ 树内部结点只需要1个盘快。当需要把内部结点读入内存中的时候，B 树就比B+ 树多一次盘块查找时间(在磁盘中就是盘片旋转的时间)。

* （2）B+tree的查询效率更加稳定 
由于非叶子结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。

* （3）B树在提高了磁盘IO性能的同时并没有解决元素遍历的效率低下的问题。正是为了解决这个问题，B+树应运而生。B+树只要遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作（或者说效率太低）。

##### LSM树
LSM树存储引擎的代表数据库就是HBase.

LSM树核心思想的核心就是放弃部分读能力，换取写入的最大化能力。LSM Tree ，这个概念就是结构化合并树的意思，它的核心思路其实非常简单，就是假定内存足够大，因此不需要每次有数据更新就必须将数据写入到磁盘中，而可以先将最新的数据驻留在内存中，等到积累到足够多之后，再使用归并排序的方式将内存内的数据合并追加到磁盘队尾(因为所有待排序的树都是有序的，可以通过合并排序的方式快速合并到一起)。

日志结构的合并树（LSM-tree）是一种基于硬盘的数据结构，与B+tree相比，能显著地减少硬盘磁盘臂的开销，并能在较长的时间提供对文件的高速插入（删除）。然而LSM-tree在某些情况下，特别是在查询需要快速响应时性能不佳。通常LSM-tree适用于索引插入比检索更频繁的应用系统。

LSM树和B+树的差异主要在于读性能和写性能进行权衡。在牺牲的同时寻找其余补救方案：

* （a）LSM具有批量特性，存储延迟。当写读比例很大的时候（写比读多），LSM树相比于B树有更好的性能。因为随着insert操作，为了维护B+树结构，节点分裂。读磁盘的随机读写概率会变大，性能会逐渐减弱。

* （b）B树的写入过程：对B树的写入过程是一次原位写入的过程，主要分为两个部分，首先是查找到对应的块的位置，然后将新数据写入到刚才查找到的数据块中，然后再查找到块所对应的磁盘物理位置，将数据写入去。当然，在内存比较充足的时候，因为B树的一部分可以被缓存在内存中，所以查找块的过程有一定概率可以在内存内完成，不过为了表述清晰，我们就假定内存很小，只够存一个B树块大小的数据吧。可以看到，在上面的模式中，需要两次随机寻道（一次查找，一次原位写），才能够完成一次数据的写入，代价还是很高的。

* （c）LSM优化方式：
	* Bloom filter: 就是个带随机概率的bitmap,可以快速的告诉你，某一个小的有序结构里有没有指定的那个数据的。于是就可以不用二分查找，而只需简单的计算几次就能知道数据是否在某个小集合里啦。效率得到了提升，但付出的是空间代价。
	* compact:小树合并为大树:因为小树性能有问题，所以要有个进程不断地将小树合并到大树上，这样大部分的老数据查询也可以直接使用log2N的方式找到，不需要再进行(N/m)*log2n的查询了

##### 红黑树

##### 目前常见的主要的三种存储引擎是：哈希、B+树、LSM树：

* 哈希存储引擎：是哈希表的持久化实现，支持增、删、改以及随机读取操作，但不支持顺序扫描，对应的存储系统为key-value存储系统。对于key-value的插入以及查询，哈希表的复杂度都是O(1)，明显比树的操作O(n)快,如果不需要有序的遍历数据，哈希表性能最好。
* B+树存储引擎是B+树的持久化实现，不仅支持单条记录的增、删、读、改操作，还支持顺序扫描（B+树的叶子节点之间的指针），对应的存储系统就是关系数据库（Mysql等）。
* LSM树（Log-Structured MergeTree）存储引擎和B+树存储引擎一样，同样支持增、删、读、改、顺序扫描操作。而且通过批量存储技术规避磁盘随机写入问题。当然凡事有利有弊，LSM树和B+树相比，LSM树牺牲了部分读性能，用来大幅提高写性能。

#### 小结
* B树：二叉树，每个结点只存储一个关键字，等于则命中，小于走左结点，大于走右结点；
* B-树：多路搜索树，每个结点存储M/2到M个关键字，非叶子结点存储指向关键字范围的子结点；所有关键字在整颗树中出现，且只出现一次，非叶子结点可以命中；
* B+树：在B-树基础上，为叶子结点增加链表指针，所有关键字都在叶子结点中出现，非叶子结点作为叶子结点的索引；B+树总是到叶子结点才命中；
* B*树：在B+树基础上，为非叶子结点也增加链表指针，将结点的最低利用率从1/2提高到2/3；

